# 도구는 무엇입니까? 

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/whiteboard-check-2.jpg" alt="Unit 1 planning"/>

AI 에이전트의 중요한 측면 중 하나는 ** 행동 **를 취하는 능력입니다.우리가 보았 듯이, 이것은 ** 도구 **를 사용하여 발생합니다.

이 섹션에서는 도구가 무엇인지, 효과적으로 설계하는 방법 및 시스템 메시지를 통해 에이전트에 통합하는 방법을 알게됩니다.

에이전트에게 올바른 도구를 제공하고 해당 도구의 작동 방식을 명확하게 설명함으로써 AI가 달성 할 수있는 것을 극적으로 증가시킬 수 있습니다.다이빙합시다!


## AI 도구는 무엇입니까? 

** 도구는 LLM **에 제공된 함수입니다.이 기능은 ** 명확한 목표 **를 충족해야합니다.

AI 에이전트에서 일반적으로 사용되는 도구는 다음과 같습니다.

|도구 |설명 |
| ---------------- | -------------------------------------------------------------------- |
|웹 검색 |에이전트가 인터넷에서 최신 정보를 가져올 수 있습니다.|
|이미지 생성 |텍스트 설명을 기반으로 이미지를 만듭니다.|
|검색 |외부 소스에서 정보를 검색합니다.|
|API 인터페이스 |외부 API (Github, YouTube, Spotify 등)와 상호 작용합니다.|

실제로 사용 사례를위한 도구를 만들 수 있기 때문에 이들은 예제입니다!

좋은 도구는 llm **의 힘을 보완하는 것입니다.

예를 들어, 산술을 수행 해야하는 경우 ** 계산기 도구 **를 LLM에 제공하면 모델의 기본 기능에 의존하는 것보다 더 나은 결과를 제공합니다.

또한 ** LLMS는 교육 데이터 **를 기반으로 프롬프트의 완료를 예측합니다. 이는 내부 지식에 훈련 전에 이벤트 만 포함 함을 의미합니다.따라서 에이전트에 최신 데이터가 필요한 경우 일부 도구를 통해 제공해야합니다.

예를 들어, 오늘 날씨에 대해 LLM을 (검색 도구없이) 직접 요청하면 LLM은 잠재적으로 무작위 날씨를 환각시킵니다.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/weather.jpg" alt="Weather"/>

- 도구에는 다음과 같은 도구가 포함되어야합니다.

- a ** 함수가하는 일에 대한 텍스트 설명 **.
-A * Callable * (행동을 수행 할 것).
- * 인수 * 타이핑이 있습니다.
- (선택 사항) 타이핑이있는 출력.

## 도구는 어떻게 작동합니까? 

우리가 본 것처럼 LLM은 텍스트 입력 만 수신하고 텍스트 출력을 생성 할 수 있습니다.그들은 스스로 도구를 호출 할 방법이 없습니다.에이전트에 도구를 제공하는 것에 대해 이야기 할 때, 우리는 LLM에 이러한 도구의 존재에 대해 가르치고 필요할 때 텍스트 기반 호출을 생성하도록 지시하는 것을 의미합니다.

예를 들어, 인터넷에서 날씨를 확인한 다음 LLM에 파리의 날씨에 대해 물어 보는 도구를 제공하는 경우 LLM은 이것이 "날씨"도구를 사용할 수있는 기회임을 인식합니다.LLM은 Weather Data 자체를 검색하는 대신 Call Weather_Tool ( 'Paris')과 같은 도구 통화를 나타내는 텍스트를 생성합니다.

그런 다음 ** 에이전트 **는이 응답을 읽고 도구 호출이 필요하다는 것을 식별하고 LLM을 대신하여 도구를 실행하고 실제 날씨 데이터를 검색합니다.

도구 용 단계는 일반적으로 사용자에게 표시되지 않습니다. 에이전트는 업데이트 된 대화를 LLM에 다시 전달하기 전에 새로운 메시지로 추가됩니다.그런 다음 LLM은 이러한 추가 컨텍스트를 처리하고 사용자에게 자연스러운 소리 응답을 생성합니다.사용자의 관점에서 LLM이 도구와 직접 상호 작용하는 것처럼 보이지만 실제로는 전체 실행 프로세스를 백그라운드에서 처리 한 에이전트였습니다.

향후 세션 에서이 과정에 대해 더 많이 이야기하겠습니다.

## LLM에 도구를 어떻게 제공합니까? 

완전한 대답은 압도적으로 보일 수 있지만, 우리는 본질적으로 시스템 프롬프트를 사용하여 사용 가능한 도구에 대한 텍스트 설명을 모델에 제공합니다.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/Agent_system_prompt.png" alt="System prompt for tools"/>

이것이 효과가 있으려면 매우 정확하고 정확해야합니다.

1. ** 도구가하는 일 **
2. ** 정확한 입력이 예상되는 것 **

이것이 공구 설명이 일반적으로 컴퓨터 언어 또는 JSON과 같은 표현 적이지만 정확한 구조를 사용하여 제공되는 이유입니다.그렇게하는 것은 _necessary_가 아닙니다. 정확하고 일관된 형식이 작동합니다.

이것이 너무 이론적 인 것처럼 보이면 구체적인 예를 통해 이해해 봅시다.

우리는 단순화 된 ** 계산기 ** 도구를 구현하여 두 정수를 곱할 것입니다.이것은 우리의 파이썬 구현 일 수 있습니다.

```python
def calculator(a: int, b: int) -> int:
    """Multiply two integers."""
    return a * b
```

따라서 우리의 도구는 'calculator'라고하며 ** 두 개의 정수 **를 곱하므로 다음과 같은 입력이 필요합니다.

- **`a ** (*int*) : 정수.
- **`b` ** (*int*) : 정수.

도구의 출력은 다음과 같이 설명 할 수있는 또 다른 정수 번호입니다.
- (*int*) :`a`와`b`의 곱입니다.

이 모든 세부 사항은 중요합니다.LLM이 이해할 수있는 도구를 설명하는 텍스트 문자열로 구성합시다.

```text
Tool Name: calculator, Description: Multiply two integers., Arguments: a: int, b: int, Outputs: int
```

> ** 알림 : **이 텍스트 설명은*우리가 LLM이 도구에 대해 알고 싶어하는 것입니다*.

LLM에 입력의 일부로 이전 문자열을 전달할 때 모델은이를 도구로 인식하고 입력으로 전달해야 할 사항과 출력에서 ​​기대할 사항을 알게됩니다.

추가 도구를 제공하려면 일관성이 있어야하며 항상 동일한 형식을 사용해야합니다.이 과정은 깨지기 쉬울 수 있으며 실수로 일부 세부 사항을 간과 할 수 있습니다.

더 좋은 방법이 있습니까?

### 자동 형성 도구 섹션 

우리의 도구는 파이썬으로 작성되었으며 구현은 이미 필요한 모든 것을 제공합니다.

- 그것이하는 일의 설명 이름 :`계산기 '
- 함수의 docstring 주석에 의해 제공되는 더 긴 설명 :`두 개의 정수를 곱하십시오.
- 입력과 그 유형 : 함수는 분명히 두 개의`int '를 기대합니다.
- 출력 유형.

사람들이 프로그래밍 언어를 사용하는 이유가 있습니다. 표현적이고 간결하며 정확합니다.

Python 소스 코드를 LLM 도구의 _specification_로 제공 할 수 있지만 도구가 구현되는 방식은 중요하지 않습니다.중요한 모든 것은 이름, 그것이하는 일, 예상되는 입력 및 출력입니다.

Python의 내성 기능을 활용하여 소스 코드를 활용하고 자동으로 도구 설명을 구축 할 것입니다.도구 구현은 유형 힌트, 문서 및 현명한 기능 이름을 사용한다는 것입니다.소스 코드에서 관련 부분을 추출하기위한 코드를 작성합니다.

완료되면 '계산기'기능이 도구임을 나타 내기 위해 파이썬 데코레이터 만 사용하면됩니다.

```python
@tool
def calculator(a: int, b: int) -> int:
    """Multiply two integers."""
    return a * b

print(calculator.to_string())
```

함수 정의 전에`@tool` 데코레이터를 참고하십시오.

다음에 볼 수있는 구현을 통해 Decorator에서 제공 한`to_string ()`함수를 통해 소스 코드에서 다음 텍스트를 자동으로 검색 할 수 있습니다.

```text
Tool Name: calculator, Description: Multiply two integers., Arguments: a: int, b: int, Outputs: int
```

보시다시피, 그것은 우리가 전에 수동으로 쓴 것과 같은 것입니다!

### 일반적인 도구 구현 

도구를 사용할 때마다 재사용 할 수있는 일반적인 '도구'클래스를 만듭니다.

> ** 면책 조항 : **이 예제 구현은 허구이지만 대부분의 라이브러리에서 실제 구현과 매우 유사합니다.

```python
from typing import Callable


class Tool:
    """
    A class representing a reusable piece of code (Tool).

    Attributes:
        name (str): Name of the tool.
        description (str): A textual description of what the tool does.
        func (callable): The function this tool wraps.
        arguments (list): A list of argument.
        outputs (str or list): The return type(s) of the wrapped function.
    """
    def __init__(self,
                 name: str,
                 description: str,
                 func: Callable,
                 arguments: list,
                 outputs: str):
        self.name = name
        self.description = description
        self.func = func
        self.arguments = arguments
        self.outputs = outputs

    def to_string(self) -> str:
        """
        Return a string representation of the tool,
        including its name, description, arguments, and outputs.
        """
        args_str = ", ".join([
            f"{arg_name}: {arg_type}" for arg_name, arg_type in self.arguments
        ])

        return (
            f"Tool Name: {self.name},"
            f" Description: {self.description},"
            f" Arguments: {args_str},"
            f" Outputs: {self.outputs}"
        )

    def __call__(self, *args, **kwargs):
        """
        Invoke the underlying function (callable) with provided arguments.
        """
        return self.func(*args, **kwargs)
```

복잡해 보일지 모르지만 천천히 진행하면 그것이 무엇을하는지 알 수 있습니다.우리는 다음을 포함하는 **`도구 '** 클래스를 정의합니다.

- **`name` ** (*str*) : 도구의 이름.
- **`description '** (*str*) : 도구가하는 일에 대한 간단한 설명.
- **`function '** (*Callable*) : 도구가 실행되는 기능.
- **`arguments '** (*list*) : 예상 입력 매개 변수.
- **`outputs` ** (*str*또는*list*) : 공구의 예상 출력.
- **`__call __ ()`** : 공구 인스턴스가 호출되면 함수를 호출합니다.
- **`to_string ()`** : 도구의 속성을 텍스트 표현으로 변환합니다.

다음과 같은 코드를 사용 하여이 클래스로 도구를 만들 수 있습니다.

```python
calculator_tool = Tool(
    "calculator",                   # name
    "Multiply two integers.",       # description
    calculator,                     # function to call
    [("a", "int"), ("b", "int")],   # inputs (names and types)
    "int",                          # output
)
```

그러나 우리는 Python의`검사 '모듈을 사용하여 모든 정보를 검색 할 수 있습니다!이것이`@tool` 데코레이터가하는 일입니다.

> 관심이 있으시면 다음 섹션을 공개하여 데코레이터 구현을 볼 수 있습니다.

<세부 사항>
<요약> 데코레이터 코드 </summary>

```python
import inspect

def tool(func):
    """
    A decorator that creates a Tool instance from the given function.
    """
    # Get the function signature
    signature = inspect.signature(func)

    # Extract (param_name, param_annotation) pairs for inputs
    arguments = []
    for param in signature.parameters.values():
        annotation_name = (
            param.annotation.__name__
            if hasattr(param.annotation, '__name__')
            else str(param.annotation)
        )
        arguments.append((param.name, annotation_name))

    # Determine the return annotation
    return_annotation = signature.return_annotation
    if return_annotation is inspect._empty:
        outputs = "No return annotation"
    else:
        outputs = (
            return_annotation.__name__
            if hasattr(return_annotation, '__name__')
            else str(return_annotation)
        )

    # Use the function's docstring as the description (default if None)
    description = func.__doc__ or "No description provided."

    # The function name becomes the Tool name
    name = func.__name__

    # Return a new Tool instance
    return Tool(
        name=name,
        description=description,
        func=func,
        arguments=arguments,
        outputs=outputs
    )
```

</세부 사항>

이 데코레이터를 제자리에 놓고 반복하기 위해 우리는 다음과 같은 도구를 구현할 수 있습니다.

```python
@tool
def calculator(a: int, b: int) -> int:
    """Multiply two integers."""
    return a * b

print(calculator.to_string())
```

또한 '도구'의`to_string` 메소드를 사용하여 LLM의 도구 설명으로 사용하기에 적합한 텍스트를 자동으로 검색 할 수 있습니다.

```text
Tool Name: calculator, Description: Multiply two integers., Arguments: a: int, b: int, Outputs: int
```

설명은 시스템 프롬프트에 ** 주사 **입니다.우리 가이 섹션을 시작한 예를 들어`툴 _description`을 교체 한 후 어떻게 보이는지가 있습니다.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/Agent_system_prompt_tools.png" alt="System prompt for tools"/>

[Action] (Action) 섹션에서, 우리는 에이전트가 방금 만든이 도구를 호출 할 수있는 방법에 대해 자세히 알아볼 것입니다.

### MCP (Model Context Protocol) : 통합 도구 인터페이스 

MCP (Model Context Protocol)는 ** Applications **를 LLM에 제공하는 방법을 표준화하는 ** 오픈 프로토콜 **입니다.
MCP 제공 :

- LLM이 직접 연결할 수있는 사전 구축 된 통합 목록
- LLM 제공 업체와 공급 업체 간 전환 할 수있는 유연성
- 인프라 내에서 데이터를 보호하기위한 모범 사례

이는 ** MCP를 구현하는 모든 프레임 워크가 프로토콜 내에 정의 된 도구를 활용할 수 있으며 각 프레임 워크에 대해 동일한 도구 인터페이스를 다시 구현할 필요가 없음을 의미합니다.

If you want to dive deeper about MCP, you can check our [free MCP Course](https://huggingface.co/learn/mcp-course/). 

---

도구는 AI 에이전트의 기능을 향상시키는 데 중요한 역할을합니다.

요약하기 위해, 우리는 다음을 배웠습니다.

- *어떤 ​​도구는 *: LLMS에 계산을 수행하거나 외부 데이터에 액세스하는 것과 같은 추가 기능을 제공하는 기능.

- *도구 정의 방법 *: 명확한 텍스트 설명, 입력, 출력 및 호출 가능 함수를 제공합니다.

- *도구가 필수적인 이유 *: 에이전트가 정적 모델 교육의 한계를 극복하고 실시간 작업을 처리하며 전문화 된 작업을 수행 할 수 있습니다.

이제 우리는 상담원이 어떻게 관찰하고, 생각하고 행동하는지 알 수있는 [에이전트 워크 플로우] (에이전트 워크 플로우] (에이전트 워크 플로) (에이전트 스펙트 및 구조)으로 넘어갈 수 있습니다.이것은 지금까지 우리가 다루었던 모든 것을 하나로 모으고 자신의 완전히 기능적인 AI 에이전트를 만들기위한 무대를 설정합니다.

그러나 먼저, 또 다른 짧은 퀴즈를위한 시간입니다!
